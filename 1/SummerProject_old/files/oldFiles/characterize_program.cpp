#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sched.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <pthread.h>
#include <unistd.h>
#include </home/jakob/Desktop/Summerwork/files/papi.h>
//#include "/home/root/papi/src/papi.h"
#include <math.h>
#include <vector>
#include <sys/wait.h>
#include <iostream>
#include <fstream>
#include <algorithm>

//#define PAPI_DIR "/home/jakob/Desktop/Summerwork/papi_avail"
//#define SOURCE_DIR "/home/jakob/Desktop/Summerwork/"

#define SLEEP_TIME 10000 //
#define TASK_ACTIVE_MS 5000
#define CACHE_LOWEST_SIZE 0
#define VALUE_SIZE 400			  //Samples for correlations
#define TARGET_PERCENTAGE 0.01	  //This can be discussed
#define CORRELATION_THRESHOLD 0.5 //Corr
#define SAMPLING_FREQ 1			  //ms, think about this....---???
#define CACHE_LOW_THRESHOLD 0.3
#define CACHE_HIGH_THRESHOLD 0.65
#define LLC_PC_ON 1
#define REPARTITION_LLC_PC 1
//#define LLM_DEPS 1 //IMplementera Rsquared
#define PART_TEST 0
#define SAMPLES 500
#define CUTOFF_STD_FACTOR 0.7
#define WINDOW_SIZE_DEF 100
#define JUNK_CONTAINER_SIZE 80
#define LLM_SHARK_PART 1
#define PROFILING_PART_SIZE 15

std::vector<char *> PAPI_EVENTS;

int mon_pid = 0;

typedef struct characteristics
{
	char *fp;
	char *name;
	int counters;
	int pid;
	int priority;
	double instr_hist[WINDOW_SIZE_DEF];
	double cache_hist[WINDOW_SIZE_DEF];
	double execution_time;
	double current_performance;
	double current_cache;
	double diff;
	double normal_diff;
	double max_performance;
	double desired_performance;
	int frequency;
	const char *app_arg[64] = {""};
	std::vector<std::vector<double>> event_counter_sets;
	std::vector<char *> event_name;
	std::vector<double> total_correlations;
	std::vector<std::vector<double>> segment_correlations;
	double baseline_correlation[16];
	double std_instr;
	double median_instr;

	std::vector<int> break_point_1;
	std::vector<int> break_point_2;

} task_characteristic;

static inline long long unsigned time_ns(struct timespec *const ts)
{
	/* We use monotonic to avoid any leap-problems generated by NTP. */
	if (clock_gettime(CLOCK_MONOTONIC, ts))
	{
		exit(1);
	}
	return ((long long unsigned)ts->tv_sec) * 1000000000LLU + (long long unsigned)ts->tv_nsec;
}

static int characterize_program(const char **argv, task_characteristic *input_task, int event_1, int event_2, int event_3, int event_4)
{
	pid_t my_pid;
	int status, timeout /* unused ifdef WAIT_FOR_COMPLETION */;
	char buffer_str[130];
	int retval = 0;
	long long values[7];
	PAPI_option_t opt;
	int ev_set = PAPI_NULL;
	int start_prog = 0;
	int n = 0;
	int measurements = 0;
	double ver = PAPI_VER_CURRENT;
	char event_name[20];
	std::vector<double> counter_1; //Counter_1
	std::vector<double> counter_2; //Counter_2
	std::vector<double> counter_3; //Counter_3
	std::vector<double> counter_4; //Counter_4

	long long unsigned timestamp_start;
	long long unsigned timestamp_end;
	struct timespec ts;
	printf("%d, %d, %d, %d\n",event_1,event_2,event_3,event_4);
	if (retval = PAPI_create_eventset(&ev_set) != PAPI_OK)
	{
		printf("ERROR: PAPI_create_eventset %d: %s\n", retval,
			   PAPI_strerror(retval));
		exit(-1);
	}

	printf("PAPI_assign_eventset_component()\n");
	if (retval = PAPI_assign_eventset_component((ev_set), 0) != PAPI_OK)
	{
		printf("ERROR: PAPI_assign_eventset_component %d: %s\n", retval,
			   PAPI_strerror(retval));
		exit(-1);
	}
	memset(&opt, 0x0, sizeof(PAPI_option_t));
	opt.inherit.inherit = PAPI_INHERIT_ALL;
	opt.inherit.eventset = ev_set;
	if ((retval = PAPI_set_opt(PAPI_INHERIT, &opt)) != PAPI_OK)
	{ //Most important, the papi inheritance!!!!
		printf("PAPI_set_opt error %d: %s0", retval, PAPI_strerror(retval));
		exit(-1);
	}
	if ((retval = PAPI_add_event(ev_set, PAPI_TOT_INS)) != PAPI_OK) //PAPI_TOT_INS
	{
		printf("failed to attach instructions retired");
		printf("Wrapper create: %s\n", strerror(errno));
	}
	if ((retval = PAPI_add_event(ev_set, event_1)) != PAPI_OK)
	{
		printf("failed to attach L1 misses");
		printf("Wrapper create: %s\n", strerror(errno));
	}
	if ((retval = PAPI_add_event(ev_set, event_2)) != PAPI_OK)
	{
		printf("failed to attach L2 misses");
		printf("Wrapper create: %s\n", strerror(errno));
	}
	if ((retval = PAPI_add_event(ev_set, event_3)) != PAPI_OK)
	{
		printf("failed to attach L3 misses");
		printf("Wrapper create: %s\n", strerror(errno));
	}

	timestamp_start = (double)time_ns(&ts) * 0.000001;
	int i = 0;
	if (0 == (my_pid = fork()))
	{

		i++;
		mon_pid = syscall(SYS_gettid);
		fflush(stdout);

		if (i == 1)
		{
			//printf("Child pid is: %d\n", mon_pid);
		}
		if (-1 == execve(argv[0], (char **)argv, NULL)) //run a sp file:
		{
			perror("child process execve failed [%m]");
			return -1;
		}
	}
	if ((retval = PAPI_attach(ev_set, my_pid)) != PAPI_OK)
	{
		printf("Monitor pid is: %d\n", my_pid);
		printf("Papi error: %s\n", strerror(errno));
		exit(-1);
	}
	if ((retval = PAPI_start(ev_set)) != PAPI_OK)
	{
		printf("PAPI_start error %d: %s0\n", retval, PAPI_strerror(retval));
		exit(-1);
	}
	if (PAPI_reset(ev_set) != PAPI_OK)
	{
		printf("PAPI_reset error %d: %s0\n", retval, PAPI_strerror(retval));
		exit(-1);
	}

	while (0 == waitpid(my_pid, &status, WNOHANG))
	{
		if ((retval = PAPI_read(ev_set, values)) != PAPI_OK)
		{
			printf("Failed to read the events");
		}

		PAPI_reset(ev_set);
		counter_1.push_back(values[0]);
		counter_2.push_back(values[1]);
		counter_3.push_back(values[2]);
		counter_4.push_back(values[3]);

		/*if (event_1 == PAPI_L1_TCM)
    	{
    		(*input_task).instr_ret.push_back(values[0]);
    		(*input_task).L1D_cache.push_back(values[1]);
    		(*input_task).L2D_cache.push_back(values[2]);
    		(*input_task).L3_cache.push_back(values[3]);
    	}
    	if (event_1 == PAPI_TLB_DM)
    	{

    		(*input_task).instr_ret2.push_back(values[0]);
    		(*input_task).TLB.push_back(values[1]);
    		(*input_task).BMSP.push_back(values[2]);
    		(*input_task).FLOPS.push_back(values[3]);
    	}*/

		//printf("%llu\t", values[0]);
		//fflush(stdout);
		//usleep((*input_task).frequency);
		timestamp_end = (double)time_ns(&ts) * 0.000001;

		double test = timestamp_end - timestamp_start;
		if (test > TASK_ACTIVE_MS)
		{
			kill(my_pid, SIGKILL);
			printf("Killed process");
			PAPI_reset(ev_set);
			PAPI_stop(ev_set, values);
		}

		usleep(SLEEP_TIME);
	}
	(*input_task).event_counter_sets.push_back(counter_1); //Probably in here, you instead want to plot these values as a graph rather than saving them
	(*input_task).event_counter_sets.push_back(counter_2);
	(*input_task).event_counter_sets.push_back(counter_3);
	(*input_task).event_counter_sets.push_back(counter_4);
	//printf("%s WEXITSTATUS %d WIFEXITED %d [status %d]\n",
	//         argv[0], WEXITSTATUS(status), WIFEXITED(status), status);

	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen("PAPI_TOT_INS")));
	strcpy((*input_task).event_name[0], "PAPI_TOT_INS");

	PAPI_event_code_to_name(event_1, event_name);
	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen(event_name)));
	strcpy((*input_task).event_name[1], event_name);

	PAPI_event_code_to_name(event_2, event_name);
	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen(event_name)));
	strcpy((*input_task).event_name[2], event_name);

	PAPI_event_code_to_name(event_3, event_name);
	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen(event_name)));
	strcpy((*input_task).event_name[3], event_name);

	if (1 != WIFEXITED(status) || 0 != WEXITSTATUS(status))
	{
		printf("Task 5 second characterization done!\n");
		//perror("%s failed, halt system");
		return -1;
	}
	PAPI_reset(ev_set);
	PAPI_stop(ev_set, values);
	return 0;
}

char * getline(void)
{
    char * line = (char*)malloc(100);
	char * linep = line;
    size_t lenmax = 100, len = lenmax;
    int c;

    if(line == NULL)
        return NULL;

    for(;;) {
        c = fgetc(stdin);
        if(c == EOF)
            break;

        if(--len == 0) {
            len = lenmax;
            char * linen = (char*)realloc(linep, lenmax *= 2);

            if(linen == NULL) {
                free(linep);
                return NULL;
            }
            line = linen + (line - linep);
            linep = linen;
        }

        if((*line++ = c) == '\n')
            break;
    }
    *line = '\0';
    return linep;
}

int main(int argc, char **argv) {

	FILE * fp;
	char * line = NULL;
	size_t len = 0;
	ssize_t read;
	char filepath [60];
	memset(filepath,0,60);
	const char *my_argv[64] = {""};	
	int counter1 = PAPI_NULL;
	int counter2 = PAPI_NULL;
	int counter3 = PAPI_NULL;
	int counter4 = PAPI_NULL;
	int arg_ok = 1;
	int number_app;

	if(argc == 2) 
		number_app = atoi(argv[1]);
	if(argc == 3){
		number_app = atoi(argv[1]);
		counter1 = atoi(argv[2]);
	} 
		
	else if (argc == 4){
		number_app = atoi(argv[1]);
		counter1 = atoi(argv[2]);
		counter2 = atoi(argv[3]);
	}
	else if (argc == 5){
		number_app = atoi(argv[1]);
		counter1 = atoi(argv[2]);
		counter2 = atoi(argv[3]);
		counter3 = atoi(argv[4]);
	}
	else if (argc == 6){
		number_app = atoi(argv[1]);
		counter1 = atoi(argv[2]);
		counter2 = atoi(argv[3]);
		counter3 = atoi(argv[4]);
		counter4 = atoi(argv[5]);
	}
	//doit changer tt ca mais tranquille
	if(number_app == 1){
		strcpy(filepath, "/home/jakob/Desktop/Summerwork/arm_test/Matmult/matmult"); 
		printf("You choose the matmult application\n");   	
	}	
	if(number_app == 2){
		strcpy(filepath, "/home/jakob/Desktop/Summerwork/arm_test/FAST_bench/fast");
		printf("You choose the fast application\n");	    	
	}
	if(number_app == 3){
		strcpy(filepath, "/home/jakob/Desktop/Summerwork/arm_test/SIFT_bench/sift");
		printf("You choose the fast application\n");	    	
	}
	if(number_app == 4){
		strcpy(filepath, "/home/jakob/Desktop/Summerwork/arm_test/SUSAN_bench/susan");
		printf("You choose the susan application\n");	    	
	}	
	if(number_app == 5){
		strcpy(filepath, "/home/jakob/Desktop/Summerwork/arm_test/HARRIS_bench/harris");
		printf("You choose the harris application\n");	    	
	}
	printf("Number_counters_vector: %d, %d, %d, %d\n\n", counter1, counter2, counter3, counter4);
	fp = fopen(filepath, "r");
	if (fp == NULL)
	{
		printf("Could not read file\n");
		exit(EXIT_FAILURE);
	}

		/*char * temp_name =(char*)malloc(sizeof(my_argv[0]));
		task_characteristic output;		
		characterize_program(output.app_arg, &output, counter1, counter2, counter3, counter4);*/
		// in this fonction -- output:app_arg (fullpath)
		//					-- &output (argument)
		//					-- counters
		// in the main project characterize_program is run in characterise_pid

		//counter returned by the interface (4 max)
		//interfqce car return the  -- core
		//							-- path of the application 
		//							-- arguments (numbers for matmult / img .bmp for FAST; SUSAN, etc)

		// run with sudo 

	}