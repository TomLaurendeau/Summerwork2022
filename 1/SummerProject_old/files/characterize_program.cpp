#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sched.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <pthread.h>
#include <unistd.h>
#include </home/jakob/Desktop/Summerwork/files/papi.h>
//#include "/home/root/papi/src/papi.h"
#include <math.h>
#include <vector>
#include <sys/wait.h>
#include <iostream>
#include <fstream>
#include <algorithm>

//#define PAPI_DIR "/home/jakob/Desktop/Summerwork/papi_avail"
//#define SOURCE_DIR "/home/jakob/Desktop/Summerwork/"

#define SLEEP_TIME 10000 //
#define TASK_ACTIVE_MS 5000
#define CACHE_LOWEST_SIZE 0
#define VALUE_SIZE 400			  //Samples for correlations
#define TARGET_PERCENTAGE 0.01	  //This can be discussed
#define CORRELATION_THRESHOLD 0.5 //Corr
#define SAMPLING_FREQ 1			  //ms, think about this....---???
#define CACHE_LOW_THRESHOLD 0.3
#define CACHE_HIGH_THRESHOLD 0.65
#define LLC_PC_ON 1
#define REPARTITION_LLC_PC 1
//#define LLM_DEPS 1 //IMplementera Rsquared
#define PART_TEST 0
#define SAMPLES 500
#define CUTOFF_STD_FACTOR 0.7
#define WINDOW_SIZE_DEF 100
#define JUNK_CONTAINER_SIZE 80
#define LLM_SHARK_PART 1
#define PROFILING_PART_SIZE 15

std::vector<char *> PAPI_EVENTS;

int mon_pid = 0;

typedef struct characteristics
{
	char *fp;
	char *name;
	int counters;
	int pid;
	int priority;
	double instr_hist[WINDOW_SIZE_DEF];
	double cache_hist[WINDOW_SIZE_DEF];
	double execution_time;
	double current_performance;
	double current_cache;
	double diff;
	double normal_diff;
	double max_performance;
	double desired_performance;
	int frequency;
	char *app_arg[64];
	std::vector<std::vector<double>> event_counter_sets;
	std::vector<char *> event_name;
	std::vector<double> total_correlations;
	std::vector<std::vector<double>> segment_correlations;
	double baseline_correlation[16];
	double std_instr;
	double median_instr;

	std::vector<int> break_point_1;
	std::vector<int> break_point_2;

} task_characteristic;

static inline long long unsigned time_ns(struct timespec *const ts)
{
	/* We use monotonic to avoid any leap-problems generated by NTP. */
	if (clock_gettime(CLOCK_MONOTONIC, ts))
	{
		exit(1);
	}
	return ((long long unsigned)ts->tv_sec) * 1000000000LLU + (long long unsigned)ts->tv_nsec;
}

static int characterize_program(char **argv, task_characteristic *input_task, int core, int event_1, int event_2, int event_3, int event_4)
{
	pid_t my_pid;
	int status, timeout /* unused ifdef WAIT_FOR_COMPLETION */;
	char buffer_str[130];
	int retval = 0;
	long long values[7];
	PAPI_option_t opt;
	int ev_set = PAPI_NULL;
	int start_prog = 0;
	int n = 0;
	int measurements = 0;
	double ver = PAPI_VER_CURRENT;
	char event_name[20];
	std::vector<double> counter_1; //Counter_1
	std::vector<double> counter_2; //Counter_2
	std::vector<double> counter_3; //Counter_3
	std::vector<double> counter_4; //Counter_4

	long long unsigned timestamp_start;
	long long unsigned timestamp_end;
	struct timespec ts;

	printf("\n- - - - - - - - - - - -\noutput.name: %s\noutput.fp: %s\n",(*input_task).name, (*input_task).fp);
	printf("%d, %d, %d, %d\n",event_1,event_2,event_3,event_4);
	
	if (retval = PAPI_create_eventset(&ev_set) != PAPI_OK)
	{
		printf("ERROR: PAPI_create_eventset %d: %s\n", retval,
			   PAPI_strerror(retval));
		exit(-1);
	}

	printf("PAPI_assign_eventset_component()\n");
	if (retval = PAPI_assign_eventset_component((ev_set), 0) != PAPI_OK)
	{
		printf("ERROR: PAPI_assign_eventset_component %d: %s\n", retval,
			   PAPI_strerror(retval));
		exit(-1);
	}
	memset(&opt, 0x0, sizeof(PAPI_option_t));
	opt.inherit.inherit = PAPI_INHERIT_ALL;
	opt.inherit.eventset = ev_set;
	if ((retval = PAPI_set_opt(PAPI_INHERIT, &opt)) != PAPI_OK)
	{ //Most important, the papi inheritance!!!!
		printf("PAPI_set_opt error %d: %s0", retval, PAPI_strerror(retval));
		exit(-1);
	}
	if ((retval = PAPI_add_event(ev_set, PAPI_TOT_INS)) != PAPI_OK) //PAPI_TOT_INS
	{
		printf("failed to attach instructions retired");
		printf("Wrapper create: %s\n", strerror(errno));
	}
	if ((retval = PAPI_add_event(ev_set, event_1)) != PAPI_OK)
	{
		printf("failed to attach L1 misses");
		printf("Wrapper create: %s\n", strerror(errno));
	}
	if ((retval = PAPI_add_event(ev_set, event_2)) != PAPI_OK)
	{
		printf("failed to attach L2 misses");
		printf("Wrapper create: %s\n", strerror(errno));
	}
	if ((retval = PAPI_add_event(ev_set, event_3)) != PAPI_OK)
	{
		printf("failed to attach L3 misses");
		printf("Wrapper create: %s\n", strerror(errno));
	}

	timestamp_start = (double)time_ns(&ts) * 0.000001;
	int i = 0;
	if (0 == (my_pid = fork()))
	{

		i++;
		mon_pid = syscall(SYS_gettid);
		fflush(stdout);

		if (i == 1)
		{
			//printf("Child pid is: %d\n", mon_pid);
		}
		if (-1 == execve(argv[0], (char **)argv, NULL))
		{
			perror("child process execve failed [%m]");
			return -1;
		}
	}
	if ((retval = PAPI_attach(ev_set, my_pid)) != PAPI_OK)
	{
		printf("Monitor pid is: %d\n", my_pid);
		printf("Papi error: %s\n", strerror(errno));
		exit(-1);
	}
	if ((retval = PAPI_start(ev_set)) != PAPI_OK)
	{
		printf("PAPI_start error %d: %s0\n", retval, PAPI_strerror(retval));
		exit(-1);
	}
	if (PAPI_reset(ev_set) != PAPI_OK)
	{
		printf("PAPI_reset error %d: %s0\n", retval, PAPI_strerror(retval));
		exit(-1);
	}

	while (0 == waitpid(my_pid, &status, WNOHANG))
	{
		if ((retval = PAPI_read(ev_set, values)) != PAPI_OK)
		{
			printf("Failed to read the events");
		}

		PAPI_reset(ev_set);
		counter_1.push_back(values[0]);
		counter_2.push_back(values[1]);
		counter_3.push_back(values[2]);
		counter_4.push_back(values[3]);

		/*if (event_1 == PAPI_L1_TCM)
    	{
    		(*input_task).instr_ret.push_back(values[0]);
    		(*input_task).L1D_cache.push_back(values[1]);
    		(*input_task).L2D_cache.push_back(values[2]);
    		(*input_task).L3_cache.push_back(values[3]);
    	}
    	if (event_1 == PAPI_TLB_DM)
    	{

    		(*input_task).instr_ret2.push_back(values[0]);
    		(*input_task).TLB.push_back(values[1]);
    		(*input_task).BMSP.push_back(values[2]);
    		(*input_task).FLOPS.push_back(values[3]);
    	}*/

		//printf("%llu\t", values[0]);
		//fflush(stdout);
		//usleep((*input_task).frequency);
		timestamp_end = (double)time_ns(&ts) * 0.000001;

		double test = timestamp_end - timestamp_start;
		if (test > TASK_ACTIVE_MS)
		{
			kill(my_pid, SIGKILL);
			printf("Killed process");
			PAPI_reset(ev_set);
			PAPI_stop(ev_set, values);
		}

		usleep(SLEEP_TIME);
	}
	(*input_task).event_counter_sets.push_back(counter_1); //Probably in here, you instead want to plot these values as a graph rather than saving them
	(*input_task).event_counter_sets.push_back(counter_2);
	(*input_task).event_counter_sets.push_back(counter_3);
	(*input_task).event_counter_sets.push_back(counter_4);
	//printf("%s WEXITSTATUS %d WIFEXITED %d [status %d]\n",
	//         argv[0], WEXITSTATUS(status), WIFEXITED(status), status);

	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen("PAPI_TOT_INS")));
	strcpy((*input_task).event_name[0], "PAPI_TOT_INS");

	PAPI_event_code_to_name(event_1, event_name);
	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen(event_name)));
	strcpy((*input_task).event_name[1], event_name);

	PAPI_event_code_to_name(event_2, event_name);
	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen(event_name)));
	strcpy((*input_task).event_name[2], event_name);

	PAPI_event_code_to_name(event_3, event_name);
	(*input_task).event_name.push_back((char *)malloc(sizeof(char) * strlen(event_name)));
	strcpy((*input_task).event_name[3], event_name);

	if (1 != WIFEXITED(status) || 0 != WEXITSTATUS(status))
	{
		printf("Task 5 second characterization done!\n");
		//perror("%s failed, halt system");
		return -1;
	}
	PAPI_reset(ev_set);
	PAPI_stop(ev_set, values);
	return 0;
}

char * getline(void)
{
    char * line = (char*)malloc(100);
	char * linep = line;
    size_t lenmax = 100, len = lenmax;
    int c;

    if(line == NULL)
        return NULL;

    for(;;) {
        c = fgetc(stdin);
        if(c == EOF)
            break;

        if(--len == 0) {
            len = lenmax;
            char * linen = (char*)realloc(linep, lenmax *= 2);

            if(linen == NULL) {
                free(linep);
                return NULL;
            }
            line = linen + (line - linep);
            linep = linen;
        }

        if((*line++ = c) == '\n')
            break;
    }
    *line = '\0';
    return linep;
}

int main(int argc, char **argv){

// initialization
	using namespace std;
	FILE * fp;
	char * line = NULL;
	size_t len = 0;
	ssize_t read;
	char filepath [60];
		memset(filepath,0,60);
	char argument[60];
		memset(argument,0,60);
	char *my_argv[64];
	char *my_argvI[64];	//test 
	int counter1 = PAPI_NULL;	int counter2 = PAPI_NULL;	int counter3 = PAPI_NULL;	int counter4 = PAPI_NULL;
	int core = -1;
	int i = 0;
	int performance_counters ;
	
// affectation
	strcpy(filepath,argv[1]);
	counter1 = atoi(argv[2]);
	counter2 = atoi(argv[3]);
	counter3 = atoi(argv[4]);
	counter4 = atoi(argv[5]);
	strcpy(argument,argv[6]);
	core = atoi(argv[7]);
	
	if(counter1 == -1) performance_counters = 0;
	else if(counter2 == -1) performance_counters = 1;
	else if(counter3 == -1) performance_counters = 2;
	else if(counter4 == -1) performance_counters = 3;
	else performance_counters = 4;

// print value in argument
	printf("argv[1]: Full Path Application selected: %s\n",filepath);
	printf("argv[2 to 5]: Counters selected: %d, %d, %d, %d. \n-> performance_counters = %d\n", counter1, counter2, counter3, counter4, performance_counters);
	printf("argv[6]: Argument selected: %s\n", argument);
	printf("argv[7]: Core selected: %d\n\n", core);

	/****************************************************************************************************************************
	 * 	EXAMPLE																													*
	 *  filepath										Counters	argument											  core 	*
	 *	/home/jakob/Desktop/arm_tests/SUSAN_bench/susan 1 24 37 -1  /home/jakob/Desktop/arm_tests/SUSAN_bench/landing.bmp 0"   	*
	 ****************************************************************************************************************************/

// open file with the filepath
	fp = fopen(filepath, "r");
	if (fp == NULL)
	{
		printf("Could not read file\n");
		exit(EXIT_FAILURE);
	}
	/*char argument_exe_c[200];
	memset(argument_exe_c,0,200);
	
	std::string argument_exe;
	argument_exe.append(filepath);
	argument_exe.append(" ");
	argument_exe.append(argument);
	argument_exe.append(" ");
	argument_exe.append(std::to_string(core)); // core here
	argument_exe.append(" ");
	argument_exe.append("1");
	int sizeOfFile = argument_exe.size();
	for (int i = 0; i < sizeOfFile; i++) {
        argument_exe_c[i] = argument_exe[i];
    }
	cout << argument_exe_c;
	cout << "\n*****************\n";
	cout << (char**)argv;

		//system(argument_exe_c); // if its Run block the programme !
		//execve(filepath, (char**)argument_exe_c, NULL); 
		if (-1 == execve(filepath, (char **)argv, NULL)) 
		{
			perror("child process execve failed [%m]");
			return -1;
		}*/

// V2 !!!
// read line by line the opened file
	while ((read = getline(&line, &len, fp)) != -1) 
	{
		char * token = strtok(line, " ");
		while( token != NULL )
		{
			my_argv[i] = (char*)malloc(sizeof(char)*64);
			strcpy(my_argv[i],token);
			token = strtok(NULL, " ");
			i++;
		}
	}	
	
	task_characteristic output;

	//if IDK (If full counter coverage ??)
	for (int j = 0; j < i; j++)
	{
		output.app_arg[j] = (char*)malloc(sizeof(char)*64);
		strcpy(output.app_arg[j], my_argv[j]);
		printf("%s\n",output.app_arg[j]);
	}
	//else my_argv[i] = my_argv[i] ??
	i=0;

	// if(performance_counters == 1)
		 PAPI_event_name_to_code(PAPI_EVENTS[0], &counter1 ); 

	//characterize_program(my_argv, &output, core, counter1, counter2, counter3, counter4); // dont need to put the core here // probalbly put in the argument fonction (execve)...

	/*
	output.fp = (char*)malloc(sizeof(char)*strlen(my_argv[0]));
	strcpy(output.fp, my_argv[0]);
	cout << output.fp;
	output.counters=4;
	my_argvI[0] = argv[1]; my_argvI[2] = argv[6]; my_argvI[3] = argv[7]; my_argvI[4] = argv[7]; my_argvI[5] = NULL; // dosnt work 

	if (-1 == execve(argv[1], my_argvI, NULL)) // DONT UNDERSTAND HOW WORK THIS FINCTION IN YOUR PROGRAM, need filepath + argument + core + 1 to work 
		{
			perror("child process execve failed [%m]");
			return -1;
		}*/

	// V1
	/*while ((read = getline(&line, &len, fp)) != -1) 
	{
		char * token = strtok(line, " ");
		while( token != NULL )
		{
			my_argv[i] = (char*)malloc(sizeof(char)*64);
			strcpy(my_argv[i],token);
			token = strtok(NULL, " ");
			printf("%s",token);

			task_characteristic output;
			double execution_time;

			printf("\n************** i=%d\n",i);
			
			for (int j = 0; j < i; j++)
			{
				output.app_arg[j] = (char*)malloc(sizeof(char)*64);
				strcpy(output.app_arg[j], my_argv[j]);
				printf("%d, %s",j, output.app_arg[j]);
			}
			output.fp = (char*)malloc(sizeof(char)*strlen(my_argv[0]));

			// //Loop to transfer arguments to struct...
			char * temp_name_tok = (char*)malloc(sizeof(my_argv[0]));
			char * temp_name =(char*)malloc(sizeof(my_argv[0]));
			strcpy(temp_name_tok, my_argv[0]);
			char * token = strtok(temp_name_tok, "/");
			printf("token: %s",token);
			while( token != NULL )
			{
				memset(temp_name, 0, sizeof(temp_name));
				int performance_counter = 0;
				strcpy(temp_name, token);
				token = strtok(NULL, "/");
			}

			output.name = (char*)malloc(sizeof(char)*strlen(my_argv[0]));
			strcpy(output.name, temp_name);
			strcpy(output.fp, my_argv[0]);
			output.execution_time = execution_time;
			output.frequency = output.execution_time / SAMPLES;
			printf("Execution time %f", output.execution_time);
			output.counters=4;
			printf("\n-----------------------\noutput.name: %s\noutput.fp: %s\n",output.name, output.fp);
			characterize_program(output.app_arg, &output, core, counter1, counter2, counter3, counter4);
			i++;
		}
	}*/

	/*while ((read = getline(&line, &len, fp)) != -1) //je pense pas besoin de lire le fichier juste le run ca sera bon !!!
	{
		char * token = strtok(line, " ");
		while( token != NULL )
		{
			my_argv[i] = (char*)malloc(sizeof(char)*64);
			strcpy(my_argv[i],token);
			token = strtok(NULL, " ");
			printf("%s\n",my_argv[i]);
			i++;
		}
		
		//task_vector.push_back(characterise_pid(my_argv, selected_rows_idx, i));  //use characterize_program in characterise_pid
		i=0;
	}*/

// close the open file and free the memory
	fclose(fp);
	if (line)
	{
		free(line);
	}	
	printf("\nEND\n");
	
// **********************************************************************************************************************************************************
	
	// characterize_program -- output.app_arg 	-> &filepath
	//						-- &output			-> argument 
	//						-- core				-> core 
	//						-- counters			-> counter1, counter2, counter3, counter4
	//characterize_program(output.app_arg, &output, core, counter1, counter2, counter3, counter4);

	
	// output.app_arg is for the filepath (application ex:matmult,...) but idk how use is : in the fonction is const char **argv but only use TODO if
		/*while ((read = getline(&line, &len, fp)) != -1)
		{
			char token = strtok(line, " ");
			while( token != NULL )
			{
				my_argv[i] = (char*)malloc(sizeof(char)*64);
				strcpy(my_argv[i],token);
				token = strtok(NULL, " ");
				i++;
			}
			task_vector.push_back(characterise_pid(my_argv, selected_rows_idx, i));  //use characterize_program in characterise_pid
			i=0;
		}*/

	//&output is for the argument -> structure need to do output.AAA (name probably)
	// how to use the number of core
	//

		// in the main project characterize_program is run in characterise_pid
		//counter returned by the interface (4 max)
		//interfqce car return the  -- core
		//							-- path of the application 
		//							-- arguments (numbers for matmult / img .bmp for FAST; SUSAN, etc)

	}