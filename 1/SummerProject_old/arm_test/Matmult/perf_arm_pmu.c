/** compile with -std=gnu99 */
#define _GNU_SOURCE
#include <malloc.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>
#include <sched.h>
#include <sys/syscall.h> 
#include <sys/types.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/resource.h>

int N = 1024;
int iteration;
int pixels_traversed = 0;
int should_connect = 0;
int temp = 0;
int should_wait = 0;
long long values[1];
int retval = 0;
static inline int
loop(int* __restrict__ a, int* __restrict__ b, int n)
{
        unsigned sum = 0;
        for (int i = 0; i < n; ++i)
                if(a[i] > b[i])
                        sum += a[i] + 5;
        return sum;
}

static inline long long unsigned time_ns(struct timespec* const ts) {
  /* We use monotonic to avoid any leap-problems generated by NTP. */
  if (clock_gettime(CLOCK_MONOTONIC, ts)) {
    exit(1);
  }
  return ((long long unsigned) ts->tv_sec) * 1000000000LLU
    + (long long unsigned) ts->tv_nsec;
}

ssize_t format_timeval(struct timeval *tv, char *buf, size_t sz) {
  ssize_t written = -1;
  struct tm *gm = gmtime(&tv->tv_sec);

  if (gm)
  {
    written = (ssize_t)strftime(buf, sz, "%Y-%m-%d.%H:%M:%S", gm);
    if ((written > 0) && ((size_t)written < sz))
    {
      int w = snprintf(buf+written, sz-(size_t)written, ".%06d", (int) tv->tv_usec);
      written = (w > 0) ? written + w : -1;
    }
  }
  return written;
}

void returntime_matmult(int **mat1, int **mat2, int **res) 
{
    int i, j, k;
    
    for (i = 0; i < N; i++) 
    {
        for (j = 0; j < N; j++) 
        { 
	    
	    
            res[i][j] = 0; 
            for (k = 0; k < N; k++) 
		{
                res[i][j] += mat1[i][k] *  
                             mat2[k][j]; 	
		}
        } 
    }
    
} 
void matmult(int **mat1, int **mat2, int **res) 
{
    
    struct timeval  t;
    char            t_str[64];
    long long unsigned timestamp;
    long long unsigned timestamp_after;
    struct timespec ts;
    double exec = 0.0;
    int i, j, k;
    int hej = 0;
    for (i = 0; i < N; i++) 
    { 
	
        for (j = 0; j < N; j++) 
        { 
	    
	    
            res[i][j] = 0; 
            for (k = 0; k < N; k++) 
		{
                res[i][j] += mat1[i][k] *  
                             mat2[k][j]; 
			pixels_traversed++;		
		}
        } 
    }
} 
void ikj_matmult(int **mat1, int **mat2, int **res)
{
	struct timeval  t;
    char            t_str[64];
    long long unsigned timestamp;
    long long unsigned timestamp_after;
    struct timespec ts;
    double exec = 0.0;
    int i, j, k = 0;
    timestamp = time_ns(&ts);
    for (i = 0; i < N; i++) 
    { 
	
        for (k = 0; k < N; k++) 
        { 
            for (j = 0; j < N; j++) 
		
                res[i][j] += mat1[i][k] *  mat2[k][j]; 
        } 
    }
    timestamp_after = time_ns(&ts);
    (void) gettimeofday(&t, NULL);

    /* Start the line with time. */
    (void) format_timeval(&t, t_str, 64);
    //printf("%28s ", t_str);
    exec = (double)(timestamp_after-timestamp);
    //printf("%.0f ns \n", exec);
}
void block_mult(int n, int** a, int** b, int** c, int b_size)
{
    int bi=0;
    int bj=0;
    int bk=0;
    int i=0;
    int j=0;
    int k=0;
    int blockSize=b_size;
    
    for(bi=0; bi<n; bi+=blockSize)
        for(bj=0; bj<n; bj+=blockSize)
            for(bk=0; bk<n; bk+=blockSize)
                for(i=0; i<blockSize; i++)
                    for(j=0; j<blockSize; j++)
                        for(k=0; k<blockSize; k++)
			{
                            c[bi+i][bj+j] += a[bi+i][bk+k]*b[bk+k][bj+j];
			}
}

/* Simple loop body to keep things interested. Make sure it gets inlined. */
int stick_this_thread_to_core(int core_id) {
  int num_cores = sysconf(_SC_NPROCESSORS_ONLN);
  if (core_id < 0 || core_id >= num_cores)
  {
    printf("Core out of index");
    return 0;
  }

  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(core_id, &cpuset);

  pthread_t current_thread = pthread_self();    
  return pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
}


void*new_matmult(void * args)
{
	int ** res;
	int ** mat1;
	int ** mat2;
	int test_size = 100; //Ã„NDRA N!!!
	N = (int)args;
	int size = (int)N;
	//printf("--------------Pthread initiated, running %dx%d 5 times\n", size, size);
	fflush(stdout);
	
		res = (int**)malloc(sizeof(int*)*size);
    		mat1 = (int**)malloc(sizeof(int*)*size);
    		mat2 = (int**)malloc(sizeof(int*)*size);
	
		for (int c = 0; c < N; c++)
    		{
			res[c] = (int*)malloc(sizeof(int)*size);
			mat1[c] = (int*)malloc(sizeof(int)*size);
			mat2[c] = (int*)malloc(sizeof(int)*size);
			for (int k = 0; k < N; k++)
			{
				mat1[c][k]=rand()%50;
				mat2[c][k]=rand()%50;
			}
    		}
		
    			srand(time(NULL));
		matmult(mat1, mat2, res);
		
		for (int c = 0; c < N; c++)
    		{
			free(res[c]);
			free(mat1[c]);
			free(mat2[c]);
    		}
		free(res);
		free(mat1);
		free(mat2);
}

int
main(int ac, char **av)
{
    
	int retval = 0;
	
	int number = 0;
	struct rlimit heap_size;
	long long time_start = 0;
	long long time_end   = 0;
	int monitor_pid = 0;
	int thread_ec = 0;
	int status = 0;
	int ** res;
	int ** mat1;
	int ** mat2;
	int rand_size;
	int i; 
	int test_size = atoi(av[1]);
	double exec_time = 0.0;
	srand(time(NULL));
	int core_aff = atoi(av[2]);
	int block_size = atoi(av[3]);
	struct timespec ts;
	double elapsed = 0.0;
    	long long unsigned timestamp;
    	long long unsigned timestamp_after;
    	
	//N = rand_size;
	stick_this_thread_to_core(core_aff);    
        //monitor_pid = getpid();
	N = test_size;
	//printf("Pid for main loop is:%d", monitor_pid);
	 if (mallopt(M_MMAP_THRESHOLD, 0) != 1) 
	{
                   fprintf(stderr, "mallopt() failed");
                   exit(EXIT_FAILURE);
        }
	while (1)
	{
       
	
	res = (int**)malloc(sizeof(int*)*N);
    	mat1 = (int**)malloc(sizeof(int*)*N);
    	mat2 = (int**)malloc(sizeof(int*)*N);
	for (int c = 0; c < N; c++)
    	{
		res[c] = (int*)malloc(sizeof(int)*N);
		mat1[c] = (int*)malloc(sizeof(int)*N);
		mat2[c] = (int*)malloc(sizeof(int)*N);
		for (int k = 0; k < N; k++)
		{
			mat1[c][k]=rand()%50;
			mat2[c][k]=rand()%50;
		}
    	}
	
	timestamp = time_ns(&ts);
	ikj_matmult(mat1, mat2, res);	
	timestamp_after = time_ns(&ts);	
	elapsed = (double)(timestamp_after - timestamp) * 0.000001;
	printf("%f\n", elapsed);
    	//printf("ms: %f\n", elapsed);
	for (int c = 0; c < N; c++)
    	{
		free(res[c]);
		free(mat1[c]);
		free(mat2[c]);
    	}
	free(res);
	free(mat1);
	free(mat2);
	}
	
}
