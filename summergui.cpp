#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sched.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <pthread.h>
#include <unistd.h>
#include </home/jakob/Desktop/Summerwork/papi.h>
//#include "/home/root/papi/src/papi.h"
#include <math.h>
#include <vector>
#include <sys/wait.h>
#include <iostream>
#include <fstream>
#include <algorithm>


#define PAPI_DIR "/home/jakob/Desktop/Summerwork/papi_avail"
#define SOURCE_DIR "/home/jakob/Desktop/Summerwork/Resource_graphs/"

#define SLEEP_TIME 10000 //
#define TASK_ACTIVE_MS 5000
#define CACHE_LOWEST_SIZE 0
#define VALUE_SIZE 400 //Samples for correlations
#define TARGET_PERCENTAGE 0.01 //This can be discussed
#define CORRELATION_THRESHOLD 0.5 //Corr
#define SAMPLING_FREQ 1 //ms, think about this....---???
#define CACHE_LOW_THRESHOLD 0.3
#define CACHE_HIGH_THRESHOLD 0.65
#define LLC_PC_ON 1
#define REPARTITION_LLC_PC 1
#define LLM_DEPS 1 //IMplementera Rsquared
#define PART_TEST 0
#define SAMPLES 500
#define CUTOFF_STD_FACTOR 0.7
#define WINDOW_SIZE_DEF 100
#define JUNK_CONTAINER_SIZE 80
#define LLM_SHARK_PART 1
#define PROFILING_PART_SIZE 15

std::vector<char*> PAPI_EVENTS;

int mon_pid = 0;

typedef struct characteristics {
	char * fp;
	char * name;
	int counters;
	int pid;
	int priority;
	double instr_hist[WINDOW_SIZE_DEF];
	double cache_hist[WINDOW_SIZE_DEF];
	double execution_time;
	double current_performance;
	double current_cache;
	double diff;
	double normal_diff;
	double max_performance;
	double desired_performance;
	int frequency;
	const char *app_arg[64] = {""};
	std::vector<std::vector<double>> event_counter_sets;
	std::vector<char*> event_name;
	std::vector<double> total_correlations;
	std::vector<std::vector<double>> segment_correlations;
	double baseline_correlation[16];
	double std_instr;
	double median_instr;

	std::vector<int> break_point_1;
	std::vector<int> break_point_2;

} task_characteristic;

static inline long long unsigned time_ns(struct timespec* const ts) {
	/* We use monotonic to avoid any leap-problems generated by NTP. */
	if (clock_gettime(CLOCK_MONOTONIC, ts)) {
		exit(1);
	}
	return ((long long unsigned) ts->tv_sec) * 1000000000LLU
			+ (long long unsigned) ts->tv_nsec;
}

ssize_t format_timeval(struct timeval *tv, char *buf, size_t sz) {
	ssize_t written = -1;
	struct tm *gm = gmtime(&tv->tv_sec);

	if (gm) {
		written = (ssize_t) strftime(buf, sz, "%Y-%m-%d.%H:%M:%S", gm);
		if ((written > 0) && ((size_t) written < sz)) {
			int w = snprintf(buf + written, sz - (size_t) written, ".%06d",
					(int) tv->tv_usec);
			written = (w > 0) ? written + w : -1;
		}
	}
	return written;
}

static int characterize_program(const char **argv, task_characteristic * input_task, int event_1, int event_2, int event_3)
{
    pid_t   my_pid;
    int     status, timeout /* unused ifdef WAIT_FOR_COMPLETION */;
    char buffer_str[130];
    int retval = 0;
    long long values[7];
    PAPI_option_t opt;
    int ev_set = PAPI_NULL;
    int start_prog = 0;
    int n = 0;
    int measurements=0;
    double ver = PAPI_VER_CURRENT;
	char event_name[20];
    std::vector<double> instr_ret;
    std::vector<double> counter_1;
    std::vector<double> counter_2;
    std::vector<double> counter_3;

    long long unsigned timestamp_start;
    long long unsigned timestamp_end;
    struct timespec ts;




    if (retval = PAPI_create_eventset(&ev_set) != PAPI_OK)
    {
    	printf("ERROR: PAPI_create_eventset %d: %s\n", retval,
    			PAPI_strerror(retval));

    	exit(-1);
    }

    printf("PAPI_assign_eventset_component()\n");
    if (retval = PAPI_assign_eventset_component((ev_set), 0) != PAPI_OK)
    {
    	printf("ERROR: PAPI_assign_eventset_component %d: %s\n", retval,
    			PAPI_strerror(retval));
    	exit(-1);
    }
    memset(&opt, 0x0, sizeof(PAPI_option_t));
    opt.inherit.inherit = PAPI_INHERIT_ALL;
    opt.inherit.eventset = ev_set;
    if ((retval = PAPI_set_opt(PAPI_INHERIT, &opt)) != PAPI_OK)
    { //Most important, the papi inheritance!!!!
    	printf("PAPI_set_opt error %d: %s0", retval, PAPI_strerror(retval));
    	exit(-1);
    }
    if ((retval = PAPI_add_event(ev_set, PAPI_TOT_INS))!= PAPI_OK) //PAPI_TOT_INS
    {
    	printf("failed to attach instructions retired");
    	printf("Wrapper create: %s\n", strerror(errno));
    }
    if ((retval = PAPI_add_event(ev_set, event_1))!= PAPI_OK)
    {
    	printf("failed to attach L1 misses");
    	printf("Wrapper create: %s\n", strerror(errno));
    }
    if ((retval = PAPI_add_event(ev_set, event_2))!= PAPI_OK)
    {
    	printf("failed to attach L2 misses");
    	printf("Wrapper create: %s\n", strerror(errno));
    }
    if ((retval = PAPI_add_event(ev_set, event_3))!= PAPI_OK)
    {
    	printf("failed to attach L3 misses");
    	printf("Wrapper create: %s\n", strerror(errno));
    }

    timestamp_start = (double)time_ns(&ts)*0.000001;
    int i = 0;
    if (0 == (my_pid = fork()))
    {

    		i++;
    		mon_pid = syscall(SYS_gettid);
    		fflush(stdout);

    		if (i==1)
    		{
    			//printf("Child pid is: %d\n", mon_pid);
    		}
            if (-1 == execve(argv[0], (char **)argv , NULL)) {
                    perror("child process execve failed [%m]");
                    return -1;

            }
    }
    if ((retval = PAPI_attach(ev_set, my_pid)) != PAPI_OK)
    {
        printf("Monitor pid is: %d\n", my_pid);
        printf("Papi error: %s\n", strerror(errno));
        exit(-1);
    }
    if ((retval = PAPI_start(ev_set)) != PAPI_OK)
    {
        printf("PAPI_start error %d: %s0\n", retval, PAPI_strerror(retval));
        exit(-1);
    }
    if (PAPI_reset(ev_set) != PAPI_OK)
    {
        printf("PAPI_reset error %d: %s0\n", retval, PAPI_strerror(retval));
        exit(-1);
    }

    while (0 == waitpid(my_pid , &status , WNOHANG))
    {
    	if ((retval = PAPI_read(ev_set, values)) != PAPI_OK)
    	{
    		printf("Failed to read the events");
    	}

    	PAPI_reset(ev_set);
    	instr_ret.push_back(values[0]);
    	counter_1.push_back(values[1]);
    	counter_2.push_back(values[2]);
    	counter_3.push_back(values[3]);

    	/*if (event_1 == PAPI_L1_TCM)
    	{
    		(*input_task).instr_ret.push_back(values[0]);
    		(*input_task).L1D_cache.push_back(values[1]);
    		(*input_task).L2D_cache.push_back(values[2]);
    		(*input_task).L3_cache.push_back(values[3]);
    	}
    	if (event_1 == PAPI_TLB_DM)
    	{

    		(*input_task).instr_ret2.push_back(values[0]);
    		(*input_task).TLB.push_back(values[1]);
    		(*input_task).BMSP.push_back(values[2]);
    		(*input_task).FLOPS.push_back(values[3]);
    	}*/

    	//printf("%llu\t", values[0]);
    	//fflush(stdout);
    	//usleep((*input_task).frequency);
    	timestamp_end = (double)time_ns(&ts)*0.000001;

    	double test = timestamp_end	 - timestamp_start;
    	if (test > TASK_ACTIVE_MS)
    	{
    		kill(my_pid, SIGKILL);
    		printf("Killed process");
    		PAPI_reset(ev_set);
    		PAPI_stop(ev_set, values);
    	}


    	usleep(SLEEP_TIME);

    }
    (*input_task).event_counter_sets.push_back(instr_ret); //Probably in here, you instead want to plot these values as a graph rather than saving them
    (*input_task).event_counter_sets.push_back(counter_1);
    (*input_task).event_counter_sets.push_back(counter_2);
    (*input_task).event_counter_sets.push_back(counter_3);
    //printf("%s WEXITSTATUS %d WIFEXITED %d [status %d]\n",
   //         argv[0], WEXITSTATUS(status), WIFEXITED(status), status);

    (*input_task).event_name.push_back((char*)malloc(sizeof(char)*strlen("PAPI_TOT_INS")));
        strcpy((*input_task).event_name[0], "PAPI_TOT_INS");

        PAPI_event_code_to_name(event_1, event_name);
        (*input_task).event_name.push_back((char*)malloc(sizeof(char)*strlen(event_name)));
        strcpy((*input_task).event_name[1], event_name);

        PAPI_event_code_to_name(event_2, event_name);
        (*input_task).event_name.push_back((char*)malloc(sizeof(char)*strlen(event_name)));
        strcpy((*input_task).event_name[2], event_name);

        PAPI_event_code_to_name(event_3, event_name);
        (*input_task).event_name.push_back((char*)malloc(sizeof(char)*strlen(event_name)));
        strcpy((*input_task).event_name[3], event_name);

    if (1 != WIFEXITED(status) || 0 != WEXITSTATUS(status)) {
            printf("Task 5 second characterization done!\n");
    		//perror("%s failed, halt system");
            return -1;
    }
    PAPI_reset(ev_set);
    PAPI_stop(ev_set, values);
    return 0;
}

int main(int ac, char **av) 
{
	//Step 1 -- read papi_avail -a, let user select counters
	//Step 2 -- insert selected counters into some vector
	//Step 3 -- use the vector as input argument for Characterize program
	//Step 4 -- Create real-time graph based on PMC values from characterize process
}
